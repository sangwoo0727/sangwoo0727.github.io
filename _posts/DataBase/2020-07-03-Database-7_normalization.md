---
title: "[데이터베이스] 정규화란"
categories:
  - DataBase
tags:
  - DataBase
comments:
  - true
read_time: false
toc: true
toc_sticky: true
---
이번 포스팅에서는 정규화에 대해 다뤄보려 한다.

데이터베이스 정규화란 데이터베이스의 설계를 재구성하는 테크닉이다. 정규화를 통해 불필요한 데이터(redundancy)를 없앨 수 있고, 삽입/갱신/삭제 시 발생할 수 있는 각종 이상현상(Anamolies)들을 방지할 수 있다.

정규화는 데이터베이스를 설계한 후 설계 결과물을 검증하기 위해 사용하기도 한다.

데이터베이스를 잘못 설계하면, 불필요한 데이터 중복이 발생하여 릴레이션에 대한 데이터의 삽입,수정,삭제 연산을 수행할 때 부작용이 발생할 수 있다.

이러한 부작용을 이상현상이라 하고, 이상현상을 제거하면서 데이터베이스를 올바르게 설계해 나가는 과정을 정규화라고 한다.

그럼 정규화에 대해 자세히 알아보기 전에 이상 현상에 대해 알아보자.

## 이상 현상
데이터베이스를 잘못 설계하면, 불필요한 데이터 중복이 발생하여 릴레이션에 대한 데이터의 삽입,갱신,삭제 연산을 수행할 때 발생하는 부작용을 이상현상이라고 하였다.

이상 현상에는 삽입 이상, 갱신 이상, 삭제 이상이 있다.

__삽입 이상이란 새 데이터를 삽입하기 위해 원치 않는 불필요한 데이터도 함께 삽입해야 하는 문제를 말한다.__

어떤 사이트에서 이벤트 참여 릴레이션을 만들었다고 해보자. 이 릴레이션은 고객들이 이벤트에 참여한 결과를 저장하고 있는 릴레이션이다.

이 릴레이션에는 이벤트에 대한 정보 뿐만 아니라, 고객 정보에 대한 속성 역시 있다고 해보자.(고객이름,고객등급 등등)

한 고객이 여러 이벤트에 참여할 수 있으므로 기본키는 고객아이디 + 이벤트참여번호로 해야 한다.

만약, 새로운 회원이 가입을 해서 이벤트 릴레이션에 고객 데이터를 삽입한다고 할 때, 이벤트에 아직 참여를 안했다면, 기본키는 널값을 가질 수 없으므로 삽입을 할 수 없게 된다. 따라서, 억지로 삽입하기 위해 임시 이벤트 번호를 삽입해야 하므로 삽입 이상이 발생하게 되는 것이다.

__갱신 이상은 중복된 튜플들 중 일부만 수정하여 데이터가 불일치하게 되는 모순이 발생하는 이상을 말한다.__

이벤트 참여 릴레이션에 아이디가 james인 고객 튜플이 3개가 존재한다고 해보자. 그렇다면, 고객 아이디, 고객 이름, 등급 속성 값 등이 중복되어 있을 것이다.

아이디가 james인 고객의 등급이 gold -> plat으로 바뀐다면, 세개의 튜플 등급 속성 모두 수정되어야 한다. 만약 이 때 1개의 튜플은 수정이 안된다면 데이터 불일치가 발생하게 되고, 갱신 이상이 발생한다.

__삭제 이상은 릴레이션에서 튜플을 삭제하면 꼭 필요한 데이터까지 함께 삭제하여 데이터가 손실되는 연쇄 삭제 현상을 말한다.__

만약, james라는 고객이 이벤트 1개를 신청하였는데, 참여를 취소하여 이벤트 참여 릴레이션에서 관련 튜플을 삭제한다고 해보자. 튜플 하나만 삭제하면 되지만 이 튜플은 이벤트 정보만 가지고 있는 것이 아니라 고객에 대한 정보도 유일하게 가지고 있다.

따라서 이 튜플을 삭제하면 이벤트 참여와 관련이 없음에도 불구하고 고객 정보까지 손실되는 삭제 이상이 발생한다.

## 정규화의 필요성
이벤트 참여 릴레이션에 여러 이상현상이 발생하는 이유는 명백하다.

관련이 없는 데이터들을 하나의 릴레이션에 모아두고 있기 때문이다. 이상현상이 발생하지 않으려면 관련 있는 속성들로만 릴레이션을 구성해야 한다.

정규화는 이상현상이 발생하지 않도록, 릴레이션을 관련이 있는 속성들로만 구성하기 위해 릴레이션을 분해하는 과정이다.

정규화를 수행하려면 먼저 릴레이션을 구성하는 속성들 간의 관련성을 판단할 수 있어야 한다. 정규화 과정에서 고려해야 하는 속성들 간의 관련성을 함수적 종속성(Functional Dependency)라고 한다.

__일반적으로 릴레이션에 함수적 종속성이 하나 존재하도록 정규화를 통해 릴레이션을 분해한다.__

그러면, 정규화를 진행하기 전에 함수적 종속성에 대해 알아보도록 하자!

## 함수적 종속성
하나의 릴레이션을 구성하는 속성들의 부분집합을 X,Y라 할 때, 모든 튜플에서 하나의 X에 대한 Y값이 하나면 X가 Y를 함수적으로 결정한다 또는 Y가 X에 함수적으로 종속되어있다 라고 한다.

X->Y 일 때, X를 결정자 Y를 종속자라고 한다.

사용자 릴레이션을 예로 들었을 때, 사용자 아이디 속성 값에 대응되는 사용자 이름 속성 값은 단 하나이므로 사용자 아이디가 사용자 이름을 결정한다.

그러므로 사용자 릴레이션에서 사용자 이름은 사용자 아이디 속성에 함수적으로 종속되어 있으며, 사용자 아이디는 결정자, 사용자 이름은 종속자가 된다.

함수 종속 관계를 판단할 때 유의점은 현재 시점에 릴레이션에 포함된 속성 값만으로 판단하면 안되고, 속성 자체가 가지고 있는 특성과 의미를 기반으로 판단해야 한다.

일반적으로, 튜플을 유일하게 구별하는 기본키와 후보키는 그 특성 때문에 릴레이션을 구성하는 다른 모든 속성들을 함수적으로 결정한다. 하지만 꼭 기본키와 후보키만 X(결정자)가 되는 것은 아니다. 속성 Y를 유일하게 결정하는 속성 X는 모두 결정자가 될 수 있다. 다만 이런 경우에는 여러 튜플의 속성 X 값이 같으면 속성 Y값도 모두 같아야 한다.

## 부분 함수 종속과 완전 함수 종속
위에서 이야기했던 이벤트 참여 릴레이션에 대해 생각해보자.

속성으로 아이디, 이벤트 번호, 이름, 당첨 여부가 있다고 할 때,

```
아이디 -> 이름
{아이디, 이벤트 번호} -> 당첨 여부
{아이디, 이벤트 번호} -> 이름
```

이런 식의 함수 종속 관계가 생긴다.

이때, 이름 속성은 {아이디,이벤트 번호}에도 종속되어 있지만 일부분인 아이디에도 종속되어 있다. 이런 경우 __이름 속성이 {아이디, 이벤트번호} 속성 집합에 부분 함수 종속 되었다고 한다.__

반면, 당첨여부 속성은 {아이디,이벤트 번호}의 일부분이 아닌 속성 집합 전체에 종속되고, __이런 경우 당첨여부 속성이 완전 함수 종속 되었다고 한다.__

즉 정리하면,

__완전 함수 종속(Full Functional Dependency)는 릴레이션에서 속성 집합 Y가 속성 집합 X에 함수적으로 종속되어있지만, 속성 집합 X 전체에 종속된 것을 의미한다.__

반대로 __부분 함수 종속(Partial Functional Dependency)는 속성 집합 Y가 속성 집합 X의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미하고, 그러기 위해서는 결정자가 여러 개의 속성들로 구성되어야 한다.__

마지막으로 함수 종속 관계에서 당연한 함수 종속 관계는 고려하지 않는다.

예를 들어, 결정자와 종속자가 같거나, 결정자가 종속자를 포함하는 등의 경우 말이다.

## 출처
__데이터베이스 개론 2판, 한빛아카데미__

