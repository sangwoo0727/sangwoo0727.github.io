---
title: "[데이터베이스] 병행 제어"
categories:
  - DataBase
tags:
  - DataBase
comments:
  - true
read_time: false
toc: true
toc_sticky: true
---
병행 제어를 이해하기 위해서는 먼저 병행 수행에 대해 알아야 한다.

데이터베이스 관리 시스템은 여러 사용자가 데이터베이스를 동시에 공유할 수 있도록 여러 개의 트랜잭션이 동시에 수행되는 병행 수행을 지원한다.

병행 수행은 실제로는 여러 트랜잭션이 차례로 번갈아 수행되는 인터리빙 방식으로 진행된다.

병행 수행되는 트랜잭션들이 서로 다른 데이터를 사용하여 연산을 실행하는 경우는 상관이 없지만, 동시에 같은 데이터에 접근하여 변경 연산을 실행하려고하면 문제가 생길 수 있다.

여러 개의 트랜잭션이 병행 수행되면서 같은 데이터에 접근하여 연산을 실행하더라도, 문제가 발생하지 않고 정확한 수행 결과를 얻을 수 있도록 트랜잭션의 수행을 제어하는 것을 __병행 제어(Concurrency Control)__ 이라고 한다.

## 병행 수행의 문제
병행 수행을 특별한 제어 없이 진행하면 여러 문제가 발생할 수 있다.

__갱신 분실__ 문제는 하나의 트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써 변경 연산이 무효화 되는 것을 말한다.

데이터 X = 10 에 10을 더하는 트랜잭션 T1과 3을 곱하는 트랜잭션 T2가 병행 수행 된다고 해보자.

```
T1                  T2
read(X);
                read(X);
X = X + 10;
                X  = X * 3;
write(X);
                write(X);
```

이런 경우, T1이 X의 원래 값인 10을 읽어오고, T2 역시 10을 읽어온다.

그 후, T1은 읽어온 10에 10을 더하고, T2는 읽어온 10에 *3을 진행한다.

마지막으로 T1이 20을 데이터베이스 X값으로 변경한다. 하지만 T2역시 30을 X값으로 변경하며, T1의 변경연산이 실제로 반영되지 않게 된다.

T1에 대한 갱신 분실이 발생한 것이다.

정확한 병행 수행은 T1 수행이 먼저 완료된 후, T2가 수행되어 정확한 결과값을 얻는 것처럼 순차적으로 수행한 것과 같은 결과 값을 얻어야한다.

__모순성__ 은 하나의 트랜잭션이 여러 개의 데이터 변경 연산을 실행할 때 일관성 없는 상태의 데이터베이스에서 데이터를 가져와 연산을 실행함으로써 모순된 결과가 발생하는 것을 말한다.

x= 10, y=10일 때 트랜잭션 T1은 x와 y를 10씩 증가시키고, T2는 x와 y를 2배 증가시키는 트랜잭션이라고 할 때, 병행 수행에서 나타나는 모순성 문제에 대해 알아보자.

```
T1            T2
read(x)
x = x + 10
write(x)
            read(x)
            x = x * 2
            write(x)
            read(y)
            y = y * 2
            write(y)
read(y)
y = y + 10
write(y)
```

이런 경우, 트랜잭션 T1이 자신이 수행을 시작하기 전 상태의 데이터 Y 값 10이 아닌, 트랜잭션 T2가 변경한 20에 대해 연산을 수행하는 모순이 발생한다.

이 역시도, 제어 없이 동시에 수행하면, 정확한 트랜잭션 수행 결과를 얻을 수 없어 모순 상태가 된다.

순차적으로 수행한 것과 같은 결과 값을 얻을 수 있어야 정확한 병행 수행이라고 할 수 있다.

__연쇄 복귀는__ 트랜잭션이 완료되기 전에 장애가 발생하여 rollback 연산을 수행하면, 이 트랜잭션이 장애 발생 전에 변경한 데이터를 가져가 변경 연산을 실행한 또 다른 트랜잭션에도 rollback 연산을 연쇄적으로 실행해야 한다는 것이다.

다만 여기서 장애가 발생한 트랜잭션이 rollback을 실행하기 전에 변경한 데이터를 가져가 사용한 다른 트랜잭션이 수행을 완료해버리면 rollback을 할 수 없어 큰 문제가 야기된다.

이처럼 두 트랜잭션을 동시에 수행하더라도 연쇄 복귀의 문제가 발생하지 않고 순차적으로 수행한 것과 같은 결과 값을 얻을 수 있어야 정확한 병행 수행이라 할 수 있다.

## 트랜잭션 스케쥴
병행 수행에서는 트랜잭션들이 차례로 번갈아 가면서 수행되는 인터리빙 방식으로 진행된다고 하였다. 

트랜잭션에 있는 연산을 수행하는 순서에 따라 트랜잭션들의 수행 결과가 달라지기도 하고, 병행 수행의 문제가 발생하기도 하므로, 트랜잭션들의 연산을 실행하는 순서는 매우 중요하다.

__트랜잭션 스케쥴은 트랜잭션에 포함되어 있는 연산들을 수행하는 순서이다.__

트랜잭션 스케쥴을 크게 3가지가 있다.

__직렬 스케쥴, 비직렬 스케쥴, 직렬 가능 스케쥴__

지금부터 이 세개의 스케쥴에 대해 알아보자

## 직렬 스케쥴
직렬 스케쥴은 인터리빙 방식을 이용하지 않고, 각 트랜잭션별로 연산들을 순차적으로 실행시키는 것이다. 모든 트랜잭션이 완료될 때까지 다른 트랜잭션의 방해를 받지 않고 독립적으로 수행된다. 항상 모순이 없는 정확한 결과를 얻을 수 있다.

같은 트랜잭션을 대상으로 하더라도 트랜잭션의 수행 순서에 따라 다양한 직렬 스케쥴이 만들어질 수 있고, 직렬 스케쥴마다 데이터베이스에 반영되는 최종 결과가 달라질 수 있다.

직렬 스케쥴의 결과는 모두 정확하기 때문에 어떤 직렬 스케쥴을 사용하는 가는 중요하지 않다.

하지만, 인터리빙 방식을 사용하지 않고 각 트랜잭션을 독립적으로 수행하기 때문에 병행 수행이라고 할 수 없다. 잘 사용되지 않는다.

## 비직렬 스케쥴
비직렬 스케쥴을 인터리빙 방식을 이용하여 트랜잭션을 병행해서 수행시킨다. 비직렬 스케쥴을 돌아가면서 연산들을 실행하기 때문에 하나의 트랜잭션이 완료되기 전에 다른 트랜잭션의 연산이 실행될 수 있다.

병행 수행을 하기때문에 갱신 분실, 모순성, 연쇄 복귀 등의 문제가 발생하여 결과의 정확성을 보장할 수 없다.

## 직렬 가능 스케쥴
직렬 가능 스케쥴은 직렬 스케쥴에 따라 수행한 것과 같이 정확한 결과를 생성하는 비직렬 스케쥴이다.

모든 비직렬 스케쥴이 직렬 가능한 것은 아니다.

직렬 스케쥴은 인터리빙 방식을 이용하지 않고 트랜잭션들이 독립적으로 수행되므로 병행 수행이 아니지만, 정확한 결과를 얻을 수 있는 반면, 직렬 가능 스케쥴은 인터리빙 방식을 이용하여 여러 트랜잭션을 병행 수행하면서도 정확한 결과를 얻을 수 있다.

직렬 가능 스케쥴을 이용해 트랜잭션을 병행 수행해야 하지만 직렬 가능 스케쥴인지 여부를 판단하는 일은 쉽지 않다. 

대부분의 데이터베이스 관리 시스템에서는 직렬 가능 스케쥴인지 검사하기보다는 직렬 가능성을 보장하는 병행 제어 기법을 사용한다. 

## 병행 제어 기법
병행 제어 기법은 여러 트랜잭션을 병행 수행하면서도 정확한 결과를 얻을 수 있는 직렬 가능성을 보장받기 위해 사용한다.

병행 제어 기법의 원리는 모든 트랜잭션이 따르면 직렬 가능성이 보장되는 규약을 정의하고, 트랜잭션들이 이 규약을 따르게 하는 것이다.

__즉, 스케쥴 내의 모든 트랜잭션이 병행 제어 기법에서 정의한 규약에 따르면 해당 스케쥴을 직렬 가능성을 보장할 수 있다.__

우리는 로킹 기법이라는 가장 많이 사용되는 병행 제어 기법에 대해 알아보려 한다.

__로킹 기법은 병행 수행되는 트랜잭션들이 동일한 데이터에 동시에 접근하지 못하도록 lock과 unlock이라는 2개의 연산을 이용해 제어한다.__

로킹 기법의 기본 원리는 한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 모두 마칠 때까지, 해당 데이터에 다른 트랜잭션이 접근하지 못하도록 상호배제(mutual exclusion)하여 직렬 가능성을 보장하는 것이다.

__lock 연산은 트랜잭션이 사용할 데이터에 대한 독점권을 가지기 위해 사용하고, unlock 연산은 트랜잭션이 데이터에 대한 독점권을 반납하기 위해 사용한다.__

로킹기법을 이용해 트랜잭션이 데이터베이스에 있는 데이터에 접근하는 연산을 실행하려면, 먼저 해당 데이터에 lock 연산을 실행하여 독점권을 획득해야 한다.

read와 write 연산은 실행하기 전에 반드시 lock 연산을 해야한다.

이미 다른 트랜잭션이 lock 연산을 실행한 데이터에는 lock 연산을 실행할 수 없다. 그 트랜잭션이 unlock 연산을 실행해서 독점권을 반납해야 한다.

이 때, __로킹 단위란 lock 연산을 실행하는 대상 데이터의 크기를 말한다.__

만약, 전체 데이터베이스에 lock 연산을 실행하면 제어가 간단하지만, 데이터베이스에 하나의 트랜잭션만 수행되므로 병행 수행이라고 할 수 없다.

반면, 가장 작은 단위인 속성에 lock 연산을 하면 독점하는 범위가 좁아 많은 수의 트랜잭션이 병행 수행할 수 있지만, 제어가 복잡해진다.

```
로킹 단위가 커질수록 병행성은 낮아지지만 제어가 쉽고, 로킹 단위가 작아질수록 제어가 어렵지만 병행성이 높아진다.
```

이 때 하나의 제약에 대해 생각해보자.

트랜잭션이 데이터를 변경하는 write연산을 실행할 때는 다른 트랜잭션이 방해하지 못하도록 독점권을 가져야하지만, 단순히 읽기만 하는 read연산일 때도 다른 트랜잭션이 read를 하면 안되는 것일까?

트랜잭션들이 하나의 데이터에 read를 동시에 실행할 수 있도록 처리 효율성을 높힐 수 있다.

__공용 lock은 트랜잭션이 데이터에 대해 공용 lock을 실행하면, 해당 데이터에 대해 read 연산은 할 수 있지만 write연산은 할 수 없게 된다. 해당 데이터의 다른 트랜잭션도 공용 lock은 동시에 할 수 있다. 즉, 데이터에 대한 사용권을 여러 트랜잭션이 가질 수 있게된다.__

반면, __전용 lock은 트랜잭션이 데이터에 전용 lock을 실행하면, 해당 데이터에 대한 read와 write 모두 실행할 수 있지만, 다른 트랜잭션은 공용이든 전용이든 어떠한 lock 연산도 할 수 없다.__

하지만 이러한 기본 로킹 규약만으로는 트랜잭션 스케쥴의 직렬 가능성을 완벽히 보장할 수 없다.

예를 들어, x와 y가 30이고, 트랜잭션 T1은 x와 y에 10을 더하고, 트랜잭션 T2는 x와 y에 2를 곱하는 연산을 한다고 했을 때,

두 직렬스케쥴의 결과는 80,80이든 70,70이어야 한다.

```
T1              T2
lock(x)
read(x)
x = x + 10
write(x)
unlock(x)
                lock(x)
                read(x)
                x = x * 2
                write(x)
                unlock(x)
                lock(y)
                read(y)
                y = y * 2
                write(y)
                unlock(y)
lock(y)
read(y)
y = y + 10
write(y)
unlock(y)
```


하지만 기본 로킹 규약으로 80,70이 되는 결과 값이 되는 경우가 있다. 즉, 트랜잭션 스케쥴의 직렬 가능성을 보장하려면 기본 로킹 규약만으로는 부족하고, lock과 unlock 연산을 실행하는 시점에 대한 새로운 규약이 필요하다. 이것이 2단계 로킹 규약이다.

트랜잭션 스케쥴의 모든 트랜잭션이 2단계 로킹 규약을 준수하면 직렬 가능성이 보장된다.

__확장 단계 : 트랜잭션이 lock 연산만 실행할 수 있고, unlock 연산은 실행할 수 없는 단계__

__축소 단계 : 트랜잭션이 unlock 연산만 실행할 수 있고, lock 연산은 실행할 수 없는 단계__

트랜잭션이 처음 수행되면 확장 단계로 들어가 lock 연산만 실행할 수 있다. 후에, unlock 연산을 실행하면, 축소단계로 들어가 unlock 연산만 실행하게 된다.

위에서 보인 예제는 2단계 로킹 규약을 전혀 지키고 있지 않기 때문에 직렬 가능성을 보장할 수 없는 것이다.

T2 트랜잭션에서 unlock(x)를 하여 축소 단계로 들어갔는데, lock 연산을 수행하고 있다.

아래의 예제를 통해 직렬 가능성을 보장해보자.

```
T1              T2
lock(x)                         T1 트랜잭션 확장단계 들어감
read(x)
x = x + 10
write(x)
lock(y)
unlock(x)                       T1 트랜잭션 축소단계 들어감
                lock(x)         T2 트랜잭션 확장단계 들어감
                read(x)
                x = x * 2
                write(x)
read(y)                
y = y + 10
write(y)
unlock(y)               
                lock(y)         
                unlock(x)       T2 트랜잭션 축소단계 들어감
                read(y)
                y = y * 2
                write(y)
                unlock(y)
```

이처럼 2단계 로킹 규약을 적용하면 트랜잭션 스케쥴의 직렬 가능성을 보장할 수 있다. 하지만 데드락 상태는 여전히 발생할 수 있다.

교착 상태(deadlock)는 트랜잭션들이 상대가 독점하고 있는 데이터에 unlock 연산이 실행되기를 기다리면서 트랜잭션의 수행을 중단하고 있는 상태이다.

교착 상태에 빠지면 트랜잭션들이 더 이상 수행을 하지 못하고 상대 트랜잭션이 먼저 unlock연산을 실행해주기를 한없이 기다린다.

예를 들어, T1이 T2가 lock한 데이터 X에 접근하기 위해 T2가 unlock 연산을 실행해주기를 기다리고 있고, T2는 T1이 lock한 Y에 접근하기위해 T1이 unlock 연산을 실행해주기를 기다리고 있다면 교착 상태가 된다.

## 출처
__데이터베이스 개론 2판, 한빛아카데미__




        

