---
title: "[데이터베이스] 장애와 회복"
categories:
  - DataBase
tags:
  - DataBase
comments:
  - true
read_time: false
toc: true
toc_sticky: true
---
이번 포스팅에서는 장애와 회복에 대해 다뤄보려 한다.

트랜잭션의 특성을 보장하고, 데이터베이스를 모순이 없는 일관된 상태로 유지하기 위해 데이터베이스 관리 시스템은 회복 기능을 제공한다.

회복은 장애가 발생했을 때 데이터베이스를 장애가 발생하기 전의 일관된 상태로 복구시키는 것이다.

그렇다면 장애부터 알아보자!

## 장애의 유형
장애(Failure)는 시스템이 제대로 동작하지 않는 상태를 말한다.

__첫 번째로, 트랜잭션 장애가 있다.__

트랜잭션 장애란 트랜잭션 수행 중 오류가 발생하여 정상적으로 수행을 계속할 수 없는 상태를 말한다.

원인은 다양하다. 트랜잭션의 논리적 오류, 잘못된 데이터 입력, 처리 대상 데이터의 부재등..

__두 번째로, 시스템 장애가 있다.__

하드웨어의 결함으로 정상적으로 수행을 계속할 수 없는 상태를 말하고, 하드웨어 이상으로 메인 메모리에 저장된 정보가 손실되거나 교착 상태가 발생하는 경우 등을 말한다.

__세 번째로, 미디어 장애가 있다.__

디스크 장치의 결함으로 디스크에 저장된 데이터베이스 일부나 전체가 손상된 상태를 말한다.

## 데이터베이스의 저장 연산
데이터베이스는 기본적으로 저장 장치에 저장되며, 장애가 발생했을 때 대응하는 방법에 따라 저장 장치를 분류 할 수 있다.

__휘발성 저장장치__ : 장애가 발생하면 저장된 데이터가 손실되며, 휘발성 저장장치의 예로는 메인 메모리가 있다.

__비휘발성 저장장치__ : 장애가 발생해도 저장된 데이터 손실되지 않는다. 하지만, 저장 장치 개체에 이상이 발생하면 데이터 손실될 수 있다. 디스크 등이 예이다.

__안정 저장장치__ : 비휘발성 저장 장치를 이용해 데이터 복사본 여러 개를 만드는 방법으로, 어떤 장애가 발생해도 데이터가 손실되지 않고 데이터를 영구적으로 저장할 수 있다.

일반적으로 데이터베이스는 디스크에 상주한다. 하지만 트랜잭션이 데이터베이스의 데이터를 처리하려면, 디스크에서 메인 메모리로 가져와 이를 처리한 후 그 결과를 다시 디스크로 보내는 작업이 필요하다.

디스크와 메인 메모리 간의 데이터 이동은 블록 단위로 수행되며, 아래의 두 연산으로 수행된다.

```
input(X) : 디스크 블록에 저장되어있는 데이터를 메인 메모리 버퍼 블록으로 이동시키는 연산.
output(X) : 메인 메모리 버퍼 블록에 있는 데이터 X를 디스크 블록으로 이동시키는 연산.
```

또한, 사용자의 요구에 따라 응용프로그램에서 트랜잭션의 수행을 지시하면 메인 메모리 버퍼 블록에 있는 데이터를 프로그램의 변수로 가져오고, 데이터 처리 결과를 저장한 변수 값을 메인 메모리 버퍼 블록으로 옮기는 작업이 필요하다.

메인 메모리의 버퍼 블록과 프로그램 변수간의 데이터 이동은 아래의 두 연산이 필요하다.

```
read(X) : 메인메모리 버퍼 블록에 저장되어있는 데이터 x를 프로그램의 변수로 읽어오는 연산
write(X) : 프로그램의 변수 값을 메인 메모리 버퍼 블록에 있는 데이터 X에 기록하는 연산
```

응용프로그램에 의해 수행된 트랜잭션이 데이터베이스에 접근하여 처리할 데이터를 가져올 때 read 연산이 수행되지만, 이 연산이 정상적으로 수행되려면 디스크에서 메인 메모리 버퍼 블록으로 데이터를 가져와야 한다. 즉, 내부적으로 input 연산 실행을 요구한다.

트랜잭션이 성공적으로 완료되려면 트랜잭션의 모든 연산을 처리한 후 결과 값을 디스크의 데이터베이스에 반영해야 하는데 이를 위해 write 연산이 실행된 후 output 연산이 실행된다.

![](/assets/img/DataBase/20200704_4.jpeg)

이전 포스팅에서 다뤘던 상우가 대상이에게 5000원을 입금하는 트랜잭션을 데이터 이동 연산과 함께 표현해보자.

```
계좌 이체 트랜잭션

1. 상우 계좌에서 5000원 인출
 read(x);
 x = x - 5000;
 write(x);

2. 대상 계좌에서 5000원 입금
 read(y);
 y = y + 5000;
 write(y);
```

이러한 장애 유형과 저장 장치와 관련된 연산을 통해 장애가 발생했을 때 데이터베이스 관리 시스템이 데이터베이스를 회복시키는 주요 기법에 대해 알아보자!

## 회복 기법
회복은 데이터베이스에 장애가 발생했을 때 장애가 발생하기 전의 일관된 상태로 복구시키는 것으로, 데이터베이스 관리 시스템의 회복 관리자가 담당한다.

장애가 탐지되면 회복 관리자는 데이터베이스 복구 기능을 제공한다.

데이터베이스를 복구하는 동안 데이터베이스에 접근하여 업무를 처리할 수 없어서, 회복 작업은 빠른 시간내에 이루어져야 한다.

회복은 어떻게 일어나는 것일까?

쉽게 말해 데이터의 복사이다. 별도의 장소에 미리 복사해두고, 장애가 발생했을 때 복사본을 이용해 원래의 상태로 복원하는 것이다.

데이터의 복사 방법은 두가지가 있다.

__덤프(dump) : 데이터 베이스 전체를 다른 저장 장치에 주기적으로 복사하는 방법__

__로그(log) : 데이터베이스에서 변경 연산이 실행될 때마다 데이터를 변경하기 이전 값과 변경한 이후의 값을 별도의 파일에 기록하는 방법__

장애가 발생했을 때, 덤프나 로그 방법으로 중복 저장한 데이터를 이용해 데이터베이스를 복구하는 기본적인 방법으로는 redo연산과, undo연산이 있다.

__redo(재실행)는 가장 최근에 저장한 데이터베이스 복사본을 가져온 후 로그를 이용해 복사본이 만들어진 이후에 실행된 모든 변경 연산을 재실행하여 장애가 발생하기 직전의 데이터베이스 상태로 복구하는 방법이다.__

반면, __undo(취소)는 로그를 이용하여 지금까지 실행된 모든 변경 연산을 취소하여 데이터베이스를 원래의 상태로 복구하는 방법이다.__

이 두방법에서는 로그가 중요하다. 로그에 대해 계속해서 알아보자!

## 로그 레코드
로그는 데이터베이스에 대한 변경 연산과 관련하여 데이터를 변경하기 이전의 값과 변경한 이후의 값을 기록한 것이다.

로그를 저장한 파일을 로그 파일이라고 하며, 로그 파일은 레코드 단위로 분류한다.

데이터베이스에 대한 변경 연산은 트랜잭션 단위로 실행되므로 로그 레코드도 트랜잭션의 수행과 함께 기록된다.

```
<Ti, start> : 트랜잭션 Ti가 시작했음을 기록

<Ti, X, old_value, new_value> : 트랜잭션 Ti가 데이터 X를 old_value에서 new_value로 변경하는 연산을 실행했음을 기록

<Ti, commit> : 트랜잭션 Ti가 성공적으로 완료되었음을 기록

<Ti, abort> : 트랜잭션 Ti가 철회되었음을 기록
```

장애가 발생하는 시점과 유형이 다양하고, 빠른 시간 내에 복구하므로 데이터베이스 관리시스템은 다양한 회복 기법들을 사용한다.

그 중, 이 포스팅에서는 로그 회복 기법에 대해 다루도록 하겠다.

## 로그 회복 기법
로그 회복 기법은 데이터를 변경한 연산 결과를 데이터베이스에 반영하는 시점에 따라 __즉시 갱신 회복 기법__ 과 __지연 갱신 회복 기법__ 으로 나뉜다.

__즉시 갱신 회복 기법__ 은 트랜잭션 수행 중에 데이터를 변경한 연산의 결과를 데이터 베이스에 즉시 반영한다.

장애 발생에 대비하기 위해 데이터 변경에 대한 내용을 로그파일에 기록하는데, 회복 시 로그를 정상적으로 사용하려면, 트랜잭션에서 데이터 변경 연산이 실행되었을 때, 로그 파일에 로그 레코드를 먼저 기록한 후 데이터베이스 변경 연산을 반영해야 한다.

즉시 갱신 회복 기법은 장애가 발생하면, 로그 파일에 기록된 내용을 참조하여, 장애 발생 시점에 따라 redo나 undo연산을 실행하여 데이터베이스를 복구한다.

트랜잭션이 완료되기 전 장애가 발생한 경우(로그 파일에 <Ti,start> 로그 레코드는 존재하지만, <Ti, commit> 로그 레코드는 존재하지 않는 상태)는 undo 연산을 하고,

트랜잭션이 완료된 후 장애가 발생한 경우(로그 파일에 <Ti, start>로그 레코드와 <Ti, commit> 로그 레코드가 모두 존재하는 상태)는 redo 연산을 수행한다.

__지연 갱신 회복 기법__ 은 트랜잭션이 수행되는 동안에는 데이터 변경 연산의 결과를 데이터베이스에 즉시 반영하지 않고, 로그 파일에만 기록해두었다가, 트랜잭션이 부분 완료 된 후에 로그에 기록된 내용을 이용해 데이터베이스에 한 번에 반영한다.  

트랜잭셔이 수행되는 동안 장애가 발생할 경우, 로그에 기록된 내용을 버리기만 하면 데이터베이스가 원래 상태를 그대로 유지한다.

그러므로 지연 갱신 회복 기법에서는 undo는 필요가 없고, redo 연산만 필요하므로 로그 레코드에 변경 이전 값을 기록할 필요가 없다.

그러므로 변경 연산 실행에 대한 로그 레코드는  <Ti, X, new_value> 식으로 기록하면 된다.

트랜잭션이 완료 되기 전에 장애가 발생한 경우(<Ti,start> 로그 레코드만 존재하고 <Ti,commit> 로그 레코드는 존재하지 않는 상태)는 로그 내용을 무시하고 버리면 되고,

트랜잭션이 완료 된 후에 장애가 발생한 경우(<Ti,start> 로그 레코드와 <Ti, commit> 로그 레코드가 모두 존재하는 상태) 는 redo 연산을 실행하면 된다.

## 검사 시점 회복 기법
일반적으로 많이 사용되는 회복 기법은 로그 회복 기법이었지만 검사 시점 회복 기법도 존재한다.

로그를 이용한 회복 기법은 로그 전체를 분석하여, 로그에 기록된 모든 트랜잭션을 대상으로 redo나 undo 중에 적용할 회복 연산을 결정해야 한다.

로그 전체를 대상으로 회복 기법을 적용하면 회복에 너무 많은 시간이 걸릴 수 있다는 단점이 있다.

이러한 비효율성을 해결하기 위한 기법이 검사시점 회복 기법이다.

검사 시점 회복 기법은 로그 회복 기법과 같은 방법으로 로그 기록을 이용하되, 일정 시간 간격으로 검사 시점(check point)를 둔다.

장애가 발생하면, 가장 최근 검사 시점 이전의 트랜잭션에는 회복 작업을 수행하지 않고, 이후의 트랜잭션에만 회복 작업을 수행한다.

검사 범위가 정해져있으므로 불필요한 회복 작업을 수행하지 않아 회복 시간이 단축된다는 장점이 있다.

로그 레코드에 <checkpoint L> 식으로 기록을 한다. 

장애가 발생하면, 로그 파일에서 가장 최근의 <checkpoint L> 로그 레코드를 찾고 그 이후의 로그 기록에만 회복 작업을 수행한다.

## 미디어 회복 기법
데이터베이스는 비휘발성 저장 장치인 디스크에 저장된다. 디스크는 메인 메모리보다 장애가 드물게 발생하지만, 디스크 헤더의 고장 등의 원인으로 장애가 발생할 수 있다.

디스크에 발생할 수 있는 장애에 대비한 회복 기법은 미디어 회복 기법이다.

미디어 회복 기법은 전체 데이터베이스 내용을 일정 주기마다 다른 안전한 저장 장치에 복사해두는 덤프를 이용한다.

디스크 장애가 발생하면 최근에 복사해둔 덤프를 이용해 장애 발생 이전의 일관된 데이터베이스 상태로 복구한다. 로그의 내용을 토대로 필요한 redo 연산을 진행한다.

전체 데이터베이스를 다른 저장 장치에 복사하는 것은 비용이 많이 들고, 복사하는 동안에 트랜잭션 수행을 중단해야 하는 단점이 있다.

## 출처
__데이터베이스 개론 2판, 한빛아카데미__
