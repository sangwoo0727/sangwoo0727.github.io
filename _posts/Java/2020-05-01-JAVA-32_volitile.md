---
title: "[Java] volatile 키워드"
categories:
  - Java
read_time: false
tags:
  - Java
comments:
  - true
toc: true
toc_sticky: true
---
이번 포스팅에서는 Java의 volatile 키워드에 대해 알아보겠다.

자바의 volatile 키워드는 자바의 변수를 __메인 메모리에 저장__ 할 것을 명시하기 위해 사용한다.

즉, volatile 키워드가 붙은 변수는 컴퓨터의 메인 메모리로부터 읽히고, 변수에 대한 쓰기 작업 역시 메인 메모리로 직접 이루어져 CPU 캐시가 쓰이지 않게 된다.

잠시 먼저 멀티스레드에 대한 이야기를 간단히 하고 가보자

## 멀티스레드란
멀티 스레드란 1개의 응용 프로그램이 스레드로 불리는 처리 단위를 복수 생성하여 복수의 처리를 병행하는 것을 의미한다.

각각의 스레드는 개별 실행하는 프로그램이지만, 각각의 스레드는 서로 생성한 인스턴스를 공유해서 사용할 수 있다는 점이 별도의 프로그램을 돌리는 것과는 차이가 있다!


## 가시성의 문제
멀티 스레드 어플리케이션에서의 non-volatile 변수에 대한 작업은 성능 상의 이유로 CPU 캐시를 이용한다. 둘 이상의 CPU가 탑재된 컴퓨터에서 어플리케이션을 실행한다면, 각 쓰레드는 변수를 각 CPU의 캐시로 복사하여 읽어들인다.

![](/assets/img/java/20200526_1.png)

non-volatile 변수에 대한 작업은 JVM이 메인 메모리로부터 CPU 캐시로 변수를 읽어들이거나, CPU 캐시에서 메인 메모리에 데이터를 쓸 때에 어떠한 보장도 하지 않는다.

즉, 다시 말하면 JVM이 어느 시점에 메인메모리로부터 데이터를 읽어 CPU 캐시로 읽어 들이는지, 혹은 CPU 캐시들에서 메인 메모리로 데이터를 쓰는지 보장을 하지 않는다.

둘 이상의 쓰레드가 아래와 같은 SharedObject라는 클래스의 객체에 접근한다고 해보자.

```java
public class SharedObject{
    public int cnt = 0;
}
```

1번 스레드는 cnt 변수를 증가시키며, 1번 스레드와 2번 스레드가 때때로 cnt변수를 읽는다고 가정해보자.

만약 위와 같이 cnt변수가 non-volatile 이면, 언제 cnt변수의 값이 CPU cache로부터 메인메모리로 다시 쓰여졌는지에 대해 보장할 수 없다. 이것은 CPU cache의 값이 메인메모리의 값과 같지 않다는 것을 의미한다.

![](/assets/img/java/20200526_2.png)

하나의 스레드에서 변경한 값이 메인 메모리에 저장되지 않아서 다른 스레드가 이 값을 볼 수 없는 상황을 __가시성의 문제__ 라고 한다.

## The Java volatile Visibility Guarantee
volatile 키워드는 변수 가시성 문제를 해결하기 위한 것이다. 

volatile 키워드를 통해 cnt변수를 선언하면 변수에 대한 모든 쓰기가 즉시 메인 메모리로 쓰여진다. 또한 cnt변수의 모든 읽기는 메인 메모리에서 직접 읽는다.

아래 코드는 volatile 키워드를 붙혀 cnt 변수를 정의한 것이다.

```java
public class SharedObject{
  public volatile int cnt = 0;
}
```

위에서 가정했던 상황에 맞춰서, 1번 스레드는 cnt 변수의 값을 변경하고, 2번 스레드는 cnt변수를 읽기만 한다고 가정할 때, volatile로 선언한 cnt 변수는 2번 스레드에게 가시성을 보장하기에 충분하다.

하지만, 1번 스레드와 2번 스레드가 둘다 cnt변수를 증가시킬 때는 volatile 키워드만으로 충분치 않다. 이 부분에 대해서는 다시 설명하겠다.

결국! volatile 키워드의 선언은 다른 스레드의 쓰기 작업에 대한 가시성을 보장한다!!

실제로, volatile 키워드의 가시성 보장은 변수 자체를 뛰어넘는다. volatile 키워드의 가시성 보장에 대해 알아보자.

하나의 스레드가 volatile 변수를 수정할 때, 단지 이 volatile 변수만이 메인 메모리에 저장되는 것이 아니라, 이 스레드가 volatile 변수를 수정하기 전에 수정한 모든 변수들이 함께 메인 메모리에 저장된다. 그리고 스레드가 volatile 변수를 메인 메모리에서 읽어들일 때, 다른 스레드에서 volatile 변수를 수정하면서 메인 메모리로 함께 저장된 다른 모든 변수들도 메인 메모리로부터 함께 읽어들여진다.

아래의 예제를 통해 확인해보자.

```
Thread A:
    sharedObject.nonVolatile = 123;
    sharedObject.cnt = sharedObject.cnt+1;

Thread B:
    int cnt = sharedObject.cnt;
    int nonVolatile = sharedObject.nonVolatile;
```

위의 내용을 바탕으로 하면, 스레드 A가 volatile 변수인 cnt에 쓰기연산을 하기 전에 non-volatile 변수에 123을 기록한다. 그러면, 두 변수는 모두 메인 메모리로 저장된다는 것이다.

왜냐하면, 스레드가 volatile 변수를 수정하기 전에 수정한 모든 변수 역시 메인 메모리에 저장된다고 하였기 때문이다.

두번째로, 스레드 B는 sharedObject의 volatile 변수를 읽으면서 시작하는데, 이 때 non-volatile 변수 역시도 메인 메모리에서 CPU 캐시로 읽어와진다.

그리고, 이때 non-volatile 변수의 값 역시 스레드 A에 의해 수정된 값이 읽혀지게 되는 것이다.

## volatile 키워드는 만병통치약이 아니다.
volatile 키워드가 volatile 변수의 읽기/쓰기 명령을 메인 메모리로부터 수행한다는 것을 보장한다고 할지라도, volatile 선언으로 해결할 수 없는 상황들이 여전히 있다.

위에서도 언급했다시피, volatile 변수 cnt를 스레드 1만 수정하고, 스레드 1과 2가 변수를 읽는 상황에서라면 volatile 변수는 가시성을 보장한다.

하지만, 다수의 스레드가 같은 cnt 값을 증가시키는 상황이 바로 volatile 변수가 불완전해지는 상황이된다. 

![](/assets/img/java/20200526_3.png)

스레드 1이 공유 객체의 cnt값 0을 자신의 cpu 캐시에 읽어들이고, 이 값을 증가시켰지만, 아직 메인 메모리로 저장되지 않은 상황이다.

그리고 스레드 2가 같은 cnt변수를 메인 메모리에서 자신의 cpu 캐시로 읽어들였고, 이 때의 값은 여전히 0이다. 그리고 스레드 2도 이 값을 1증가 시키고 메인 메모리로 저장하지 않았다.

스레드 1과 스레드 2는 동기화가 깨진 상태가 되고, cnt변수의 실제 값은 2가 되어야 하지만, 두 스레드는 각자의 값 1을 자신들의 캐시에 가지고 있고, 메인 메모리의 값은 아직 0이다.

그리고 스레드들이 캐시에 가진 변수의 값을 메인 메모리로 쓴다고 해도, cnt의 값은 1이 되는 잘못된 상황이 된다.

## 언제 volatile 키워드가 적합할까?
위에서도 말했다시피, 두개 이상의 스레드가 공유 변수에 읽기/쓰기를 할 때 volatile 선언은 충분하지 않다. 이런 상황에서는 변수 값의 읽기 쓰기 명령의 원자성을 보장하기 위해 synchronized를 써야한다. 

한 변수를 두고 오직 한 스레드만 변수에 읽기/쓰기 작업을 하고, 다른 스레드들은 읽기 작업만 하는 상황에서라면 volatile 선언은 유효하다. 읽기 작업을 하는 스레드들은 언제나 이 변수의 가장 최근 수정된 값을 봐야하고, volatile은 이를 보장해준다.

## volatile의 성능
volatile 변수의 읽기/쓰기는 메인 메모리를 이용한다. 메인 메모리로부터 데이터를 읽고 쓰는 작업은 cpu 캐시를 이용하는 것보다 많은 비용이 요구된다. 또한 volatile 선언은 JVM의 성능 향상을 위한 코드 재정리를 막기도 한다. 그러므로 volatile 키워드는 변수의 가시성 보장이 반드시 필요한 경우에만 사용되어야 한다!




## 출처
[tutorials.jenkov.com](http://tutorials.jenkov.com/java-concurrency/volatile.html)