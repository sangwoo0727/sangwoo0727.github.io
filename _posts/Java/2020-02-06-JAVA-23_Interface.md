---
title: "[Java] 인터페이스(Interface)"
categories:
  - Java
read_time: false
tags:
  - Java
comments:
  - true
toc: true
toc_sticky: true
---
## 인터페이스란
인터페이스를 한마디로 정의해보면 구현된 것은 아무것도 업는 밑그림만 있는 설계도이다.

이런 의미에서 인터페이스는 명세, 표준, 약속, 규칙이다.

이러한 정의나 인터페이스 의미를 통해 인터페이스의 골격을 생각해볼 수 있다.

## 인터페이스의 골격 및 작성 방법
인터페이스는 일반 메서드나 멤버 변수를 가질 수 없고, 오직 추상메서드와 상수만을 멤버로 가질 수 있다.

상수만을 가질 수 있다는 부분은 뒤에서 다시 설명하겠다.

즉, 추상 클래스보다 추상화가 높다.

인터페이스는 class대신 interface라는 키워드를 사용한다. 

```java
interface 인터페이스 이름{
  public static final 타입 상수이름 = 값;
  public abstract 메서드 이름();
}
```

위에 있는 메서드의 몸체가 비어있는 메소드를 가리켜 추상메소드(Abstract Methods)라 한다.

또한 인터페이스를 대상으로는 인스턴스 생성이 불가능하다. 다른 클래스에 의해 상속이 될 수는 있다.

```java
class 클래스 implements 인터페이스{
  //인터페이스 있던 메서드 구현해야함.
}
```

다만 클래스가 인터페이스를 상속하는 행위는 상속이 아닌 구현이라고 한다. 문법 관계는 상속과 동일하지만 본질은 인터페이스 있던 것을 구현하는 것이기 때문이다.

__인터페이스 구현에 대한 특징__
* 구현할 인터페이스를 사용할 때는 implements 키워드를 사용한다.
* 한 클래스는 둘 이상의 인터페이스를 동시에 구현할 수 있다.
* 상속과 구현은 동시에 가능하다.
* 인터페이스의 형을 대상으로 참조변수의 선언이 가능하다.(객체 생성이 아님-> 인터페이스를 구현한 클래스를 통해 객체 생성해야한다, 다형성)
* 인터페이스의 추상 메소드와 이를 구현하는 메소드 사이에 오버라이딩 관계가 성립한다.(어노테이션 @Override 선언이 가능하다)

아래 코드를 통해 잠깐 설명하겠다.

```java
interface WorkBehavior{
  void work();
}

class Seeding implements WorkBehavior{
  @Override //인터페이스의 추상 메서드를 구현하며 오버라이딩 관계 성립.
	public void work() {
		System.out.println("씨앗 뿌리기");
	}
}

class Main{
  public static void main(String[] args){
    WorkBehavior wb = new Seeding(); //인터페이스 형을 대상으로 참조변수 선언
    wb.work();
  }
}
```

## 인터페이스의 문법 구성
인터페이스에 존재할 수 있는 추상 메소드, 디폴트 메소드, static 메소드가 있다.

인터페이스에 정의된 추상 메소드에는 public이 선언 된 것으로 간주한다.

또한 인터페이스에 선언되어 있는 변수는 반드시 선언과 동시에 값으로 초기화를 해야한다.

이유는 인터페이스 내 모든 변수는 public, static, final이 선언된 것으로 간주하기 때문이다.

즉 인터페이스 내 선언된 모든 변수는 상수이다.

그리고 결론은, 인터페이스를 구현하는 클래스는 인터페이스에 존재하는 모든 추상 메소드를 구현해야 한다.

## 인터페이스의 default 메소드.
이미 정의되어 있는 여러개의 인터페이스에 최소 한 개 이상의 추상 메소드를 추가하는 상황이 있다고 생각해보자.

이 때, 이 문제를 상속으로 해결하게 되면, 인터페이스의 수는 두 배로 늘어난다.

이 문제를 해결하기 위해 자바8 이상 부터, 디폴트 메소드가 소개 되었다.

디폴트 메소드는 인터페이스에 추가된 메소드라고 생각하면 된다.

인터페이스의 default 메소드는 다음과 같은 특징이 있다.
* 인터페이스 내에 선언되어 있지만, 자체로 완전한 메소드이다.
* 이를 구현하는 클래스가 오버라이딩 하지 않아도 된다.

```java
interface Printable{
  void print();
  default void printC(String s){//...};
}
```

이를 통해 알 수 있는 것은 다음과 같다.
* 처음에는 print 추상 메소드만 있었구나.
* 이후에 필요에 의해 디폴트 메소드를 추가했구나.
* 디폴트 메소드를 추가했으니, 이전에 구현된 클래스에 대해서는 영향을 주지 않는다.

즉, 디폴트메소드는 인터페이스에 추상 메소드를 추가해야 하는 상황에서, 이전에 개발해놓은 코드에 영향을 미치지 않기 위해 등장한 문법.

처음 인터페이스를 만들 때, 디폴트 메소드를 넣는다는 건 디폴트 메소드를 잘못이해하고, 잘못 사용하고 있는 것이다.

## 인터페이스의 static 메소드(클래스 메소드)
자바 8부터 인터페이스에도 static 메소드를 둘 수 있게 되었다. 

아래 코드를 봐보자.

```java
interface WorkBehavior{
  static void work(){
    System.out.println("씨앗 뿌리기");
  }
}

class Seeding implements WorkBehavior{
  //아무것도 구현하지 않았다.
}

class Main{
  public static void main(String[] args){
    WorkBehavior wb = new Seeding(); //인터페이스 형을 대상으로 참조변수 선언
    wb.work(); //씨앗 뿌리기
    WorkBehavior.work(); //인터페이스의 static 메소드 직접 호출, 씨앗 뿌리기
  }
}
```

## 참고 - 추상 클래스
추상 클래스는 하나 이상의 추상 메소드를 갖는 클래스를 가리켜 '추상 클래스'라 한다.

추상 클래스에는 클래스의 선언부에 abstract 키워드를 붙혀야한다.

추상클래스를 대상으로는 인터페이스 생성도 불가능하고, 다른 클래스에 의해서 추상메소드가 구현되어야 한다.

인터페이스와 성격이 유사하지만, 추상클래스는 클래스이다.

다른 클래스들과 마찬가지로 인스턴스 변수와 인스턴스 메소드를 가지지만, 이를 상속하는 하위 클래스에 의해서 구현되어야할 메소드가 하나 이상 있는 경우를 추상클래스라고 한다.

## 출처
__윤성우의 열혈 Java 프로그래밍, 오렌지 미디어__

__[한걸음 한걸음](https://enjoyplaying.tistory.com/33)__