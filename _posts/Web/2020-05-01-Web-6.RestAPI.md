---
title: "[WEB] REST API"
categories:
  - Web
read_time: false
tags:
  - Web
comments:
  - true
toc: true
toc_sticky: true
---
REST는 Representational State Transfer의 약자로서, 자원을 이름으로 구분하여 자원의 상태를 주고 받는 것을 의미한다.

일반적인 웹 서비스의 백엔드 서버는 웹 페이지를 응답해주었는데, 서버는 점점 더 순수하게 데이터에 대한 처리를 목적으로 하는 형태로 진화하며 리소스 즉, 데이터 중심인 REST API가 나타나게 된 것이다.

리소스 중심으로 설계를 하기 때문에 CRUD에 해당하는 HTTP의 POST, GET, PUT, DELETE 메소드를 이용한다.(추가적으로 PATCH)

## REST API의 구성요소
1. __Resource__ : 서버는 고유한 id를 가지는 리소스를 가지고 있으며, 클라이언트는 이러한 리소스에 요청을 보낸다. 이러한 리소스는 URI에 해당한다.

2. __Method__ : 서버에 요청을 보내기 위한 방식으로, 위에서 언급한 CRUD에 해당하는 HTTP 메소드를 사용하여 서버에 요청을 보낸다.

3. __Representation of Resource__ : 클라이언트와 서버가 데이터를 주고 받는 형태로, 근래에 REST를 이야기하면, HTTP + JSON을 쉽게 떠올리지만, JSON은 하나의 옵션일 뿐 메시지 포맷을 꼭 JSON으로 적용해야할 필요는 없다. 일반적인 웹 서비스의 서버는 단순히 HTML문서만을 응답해주었는데, REST API는 웹 브라우저를 포함한 HTTP 통신이 가능한 모든 클라이언트 플랫폼을 타겟으로 한다.

이러한 범용성을 갖추기 위해서 REST API의 HTTP Response Body는 JSON, XML 등 여러 플랫폼에서 사용하기 적절한 단순한 텍스트 포맷을 사용한다.

## REST API의 특징
1. __Uniform Interface (일관된 인터페이스)__ : 리소스(URI)에 대한 요청을 통일되고, 한정적으로 수행하는 아키텍쳐 스타일을 의미한다. 만약, REST API를 HTTP + JSON으로 정의를 하였다면, 요청을 하는 클라이언트가 플랫폼(Android, IOS, JSP) 등 특정 언어나, 기술에 종속받지 않고, HTTP와 JSON을 사용할 수 있는 모든 플랫폼에 사용이 가능한 느슨한 결합(Loosely coupling)형태의 구조를 갖게된 것을 말한다.

2. __Stateless (무상태성)__ : REST API는 HTTP의 특성을 이용하기 때문에 무상태성을 갖는다. 즉 서버에서 어떤 작업을 하기 위해 상태정보를 기억할 필요가 없고, 들어온 요청에 대해 처리만 해주면 되기 때문에 구현이 쉽고 단순해진다. 

REST API는 이러한 특성으로 인해 세션 정보나 쿠키 정보를 활용하여 작업을 위한 상태정보를 저장 및 관리하지 않는다. JWT(Json Web Token)등을 활용하여 인증절차를 진행한다.

상태가 있다/없다의 의미는 사용자나 클라이언트의 컨택스트(세션, 로그인 정보)가 서버에 유지되지 않는다는 의미이다. 상태 정보를 저장하지 않으면, 각 API 서버는 들어오는 요청만을 들어오는 메시지로만 처리하면 되며, 컨택스트 정보를 신경쓸 필요가 없기 때문에 구현이 단순해진다.

3. __Cacheable (캐시 가능)__ : Rest API는 HTTP의 특성을 그대로 사용하기 때문에, 웹의 기존 인프라를 그대로 활용할 수 있다. 일반적인 서비스 시스템에서 60~80% 가량의 트랜잭션이 조회성 트랙잭션임을 감안하면, HTTP 리소스들을 웹 캐시 서버에 캐싱하는 것은 많은 장점을 가져올 수 있다.

![](/assets/img/Web/20200501_1.png)

HTTP 프로토콜 표준에서 사용하는 "Last-Modified" 태그나 E-Tag를 사용하여 캐싱을 구현할 수 있다.

위의 그림과 같이 클라이언트가 HTTP GET을 "Last-Modified" 값과 함께 보냈을 때, 컨텐츠에 변화가 없다면, REST 컴포넌트는 304 Not Modified를 리턴하며, 클라이언트는 자체 캐시에 저장된 값을 사용하게 된다.

(cf. 304 Not Modified : 클라이언트 리다이렉션 응답 코드 304 Not Modified는 요청된 리소스를 재전송할 필요가 없음을 나타낸다. 캐시된 자원으로의 암묵적인 리다이렉션이다.)

이렇게 캐시를 사용하게 되면, 네트워크 응답시간 뿐만 아니라, REST 컴포넌트가 위치한 서버에 트랜잭션을 발생시키지 않기 때문에 전체 응답시간과 성능, 서버의 자원 사용률을 비약적으로 향상시킬 수 있다.

4. __Client-Server Architecture (서버-클라이언트 구조)__ : REST API에서 자원을 가지고 있는 쪽이 서버, 자원을 요청하는 쪽이 클라이언트에 해당한다. 서버가 클라이언트의 정보로부터 조금은 자유로워지는 구조이다. REST 서버는 API를 제공하고, 제공된 API를 이용해서 비즈니스 로직 처리 및 저장을 책임진다. 

이렇게 역할이 확실히 구분되면서, 개발 관점에서 클라이언트와 서버에서 개발해야할 내용들이 명확해지고, 서로의 개발에 있어서 의존성이 줄어들게 된다.

5. __Self-Descriptiveness (자체 표현)__ : API를 보고도 다 알 수 있기 때문에 별도의 문서가 필요없다. REST의 가장 큰 특징 중 하나는 REST API 자체가 매우 쉬워서 API 메세지만 보고도 API를 이해할 수 있다는 것이다. 즉 그 자체로도 자기 서술성을 갖는다는 의미이다.

리소스와 메소드를 이용하여 어떤 메소드에 무슨 행위를 하는지 알 수 있으며, 메시지 포맷 역시 JSON을 이용해서 직관적으로 이해가 가능한 구조이다.

![](/assets/img/Web/20200501_2.png)

6. __Layered System (계층형 구조)__ : REST 서버는 다중 계층으로 구성될 수 있다. 

API 서버는 순수 비즈니스 로직을 수행하고, 그 앞단에 보안, 로드 밸런싱, 암호화, 사용자 인증 등을 하는 계층을 추가해서 구조상의 유연성을 줄 수 있다.


## REST 안티 패턴
1. 가장 나쁜 디자인 중 하나가 __GET or POST를 이용한 터널링__ 이다.

http://myweb/users?method=update&id=terry 이 경우가 가장 전형적인 GET을 이용한 터널링이다. 메소드의 실제 동작은 리소스를 업데이트 하는 내용인데, HTTP PUT을 이용하지 않고, GET에 쿼리 스트링으로 method=update라고 넘겨서 이 메소드가 update 메소드임을 명시했다.

HTTP 메소드 사상을 따르지 않으며, REST라고 부를 수도 없고, 웹 캐시 인프라 등도 사용이 불가능하다.

또한 POST를 이용한 터널링도 있다. 특정 사용자 정보를 가지고 오는 API를 POST를 이용해서 만든 경우이다.

```
HTTP POST, http://myweb/users/
{
  "getuser":{
    "id":"terry"
  }
}
```

2. Self-description 속성을 사용하지 않는 것
REST URI와 메소드 그리고 쉽게 정의된 메시지 포맷에 의해서 쉽게 API를 이해할 수 있는 기능이 되어야 한다. 

위와 같이 GET이나 POST를 이용한 터널링을 이용한 구조가 대표적인 예가 된다.

3. HTTP Response code를 사용하지 않음.
1~2개의 HTTP response code만 사용하며, 심한 경우에는 에러도 200 code를 사용하여 정의한 후 별도의 에러 메시지를 200 response code에 보내는 경우이다.

이런부분은 REST 디자인 사상에도 어긋남은 물론이고, 자기 서술성에도 어긋난다.

## REST의 문제점
아직 부족한 점이 많아서, 이해하기가 쉽지 않았지만 한가지 흥미로운 부분이 있어서 그 중 하나를 남겨보려 한다.

REST의 문제점 중 __기존 전통적인 RDBMS에 적용 시키기에 쉽지 않다.__ 라는 문장을 보았다.

예를 들어, 리소스를 표현할 때 리소스는 DB의 하나의 ROW가 되는 경우가 많은데, DB의 경우는 pk가 복합 key 형태로 존재하는 경우가 많다.

DB의 경우에는 유효한 설계일지 몰라도 HTTP URI는  / 에 따라서 계층구조를 가지기 때문에 부자연스러운 표현이 될 수 있다.

예를 들어 DB의 PK가 "세대주 주민번호"+"사는 지역"+"이름" 일 때, DB에서는 이렇게 표현하는 것이 이상할 것 없으나, REST에서 이를 userinfo/{세대주 주민번호}/{사는지역}/{본인이름} 으로 표현하게 되면 다소 이상한 의미가 될 수 있다.

그래서 mongoDB 등의 NoSQL의 경우 JSON Document를 그대로 넣을 수 있는 구조를 갖추기 때문에, 하나의 도큐먼트를 하나의 REST 리소스로 취급하면 되기 때문에 REST의 리소스 구조에 맵핑하기가 쉬워진다.

NoSQL을 조만간 꼭 공부하겠다!

이외에도 resource에 대한 유니크한 키를 부여하는 것에 여러가지 에로점이 있는데, 이를 해결하는 대안으로 Alternative Key(AK)를 사용하는 방법이 있다. 의미를 가지지 않는 Unique Value를 Key로 잡아서 DB Table에 AK라는 필드로 잡아서 사용하는 방법인데, 구글의 REST도 이러한 AK를 사용하는 아키텍쳐를 채택하고 있다.

하지만, DB에 AK 필드를 추가하는 것은 전체적인 DB 설계에 대한 변경을 의미하고, REST를 위해서 전체 시스템의 아키텍쳐에 변화를 준다는 점에서 아키텍쳐적인 접근의 필요성을 의미한다.

