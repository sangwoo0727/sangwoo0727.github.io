---
title: "[네트워크] HTTP 메소드, 안정성,멱등성,캐시가능성"
categories:
  - Network
read_time: false
tags:
  - Network
comments:
  - true
toc: true
toc_sticky: true
---
이번 포스팅에서는 HTTP 메세지 중, 요청 줄에 존재하는 메서드에 대해 알아보려한다.

HTTP/1.1에서 정의한 메서드에는 총 9가지가 존재한다. 

메서드에 대해 작성하기 전에 먼저 안정성, 멱등성, 캐시가능성에 대해 알아보자.

## 안정성 (Safe)
HTTP는 안전한 메서드라 불리는 메서드의 집합이다. 

안전한 메서드의 목적은 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려줄 수 있도록 하는 것이다.

읽기 전용인 경우 안전한 메서드로 간주하며, GET, HEAD, OPTIONS 메서드는 안전한 메서드로 정의되어 있다.

즉, 리소스를 수정하지 않는 메소드들을 Safe 하다고 말한다.

## 멱등성 (Idempotent)
멱등성이란 특정 메서드의 요청을 여러번 하더라도 한번 요청했을 때와 결과가 같다면 멱등하다라고 한다.

PUT, DELETE, TRACE 및 GET, HEAD, OPTIONS가 멱등성을 갖는다.

## 캐시 가능성(Cachable)
향후 재사용을 위해 이에 대한 응답을 저장할 수 있음을 나타낸다.

현재 시점의 응답이나 권한 있는 응답에 의존하지 않는 안전한 메서드는 캐시 가능한 것으로 정의한다.

## 1. GET
GET 메소드는 서버에게 리소스를 달라고 요청하기 위해 쓰이는 메소드이다. 즉, 서버에서 어떤 데이터를 가져와서 보여주기 위한 용도의 메서드이다.

url의 ? 뒤에 데이터가 붙어서 request를 보내게 된다. url이라는 공간에 담겨가기 때문에 데이터의 크기는 제한적이다.

즉, HTTP 패킷의 바디는 비어있는 상태로 전송하게 된다. 또한 바디의 데이터 타입을 표현하는 Content-Type의 필드도 HTTP Request Header에 들어가지 않는다.

참고로 안정성과 멱등성은 신뢰할 수 없는 네트워크 상의 HTTP를 신뢰할 수 있게 만들어준다. 만약, GET요청을 하고 응답을 못 받았을 경우 한 번 더 보내더라도 이 동작은 안전하다. 

그러므로 GET은 Idempotent하며 safe하다. 먼저 보낸 요청이 벌써 처리되었다고 하더라도 서버에 다른 영향은 없다.

## 2. HEAD
HEAD 요청 방식은 GET과 유사한 방식이나 웹 서버에서 헤더 정보 이외에는 어떤 데이터도 보내지 않는다.

웹 서버의 다운 여부 점검이나 웹 서버 정보(버전 등)등을 얻기 위해 사용될 수 있다.

서버는 응답으로 헤더만을 돌려주므로, 리소스를 가져오지 않고도 그에 대해 무엇인가를 알아낼 수 있을때 사용한다. 또한 응답의 상태 코드를 통해 개체가 존재하는지 확인할 수 있으며,헤더만을 확인하여 리소스가 변경되었는지 검사할 수 있다. 추가로, 큰 용량의 리소스를 다운로드 받을지 말지 결정하기 위해서 사전 요청하는 용도로 사용할 수 있다.

HEAD 역시 Idempotent하며 safe하다.

## 3. POST
POST 요청 방식은 HTTP 메세지의 Body 부분에 데이터가 담겨서 전송되는 메소드이다. 데이터의 크기가 GET보다 크며, 아주아주 상대적으로 GET보다 보안면에서 약간 낫다.

서버에 입력 데이터를 전송하기 위해 설계된 메소드이다.

POST는 비멱등성을 갖는다. 같은 POST를 연속적으로 보낸다면 명령은 여러번 내린 것처럼 부가적인 결과를 가져온다.


## 4. PUT
POST와 유사한 전송 구조를 가지기 때문에 헤더 이외에 메세지(데이터)가 함께 전송된다. 원격지 서버에 지정한 콘텐츠를 저장하기 위해 사용되며 홈페이지 변조에 많이 악용되고 있다.

PUT 메소드의 의미는 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 자료를 만들거나, 이미 URL이 존재한다면, 본문을 사용해서 교체하는 것이다.

데이터를 변경할 수 있는 메서드이기 때문에 서버 입장에서는 위험할 수 있다.

PUT은 컨텐츠를 변경할 수 있게 해주기 때문에, 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구할 것이다.

PUT과 POST의 차이점은 PUT은 멱등하다는 것이다.

POST는 클라이언트가 __리소스의 위치를 지정하지 않았을 때 리소스를 생성하기 위해 사용하는 연산이다__. 예를 들어,

```
POST /dogs HTTP/1.1
{"name": "blue", "age":5}
HTTP/1.1 201 Created
```

이 연산을 수행하면, /dogs/2에 생기고, 그 다음번엔 /dogs/3 등 매번 다른 곳에 새로운 리소스가 생성될 수 있으므로, 이 연산은 idempotent 하지 않다.

반면, PUT은 리소스의 위치를 명확히 알고 요청을 할 경우 사용을 한다.

그렇기 때문에, PUT은 새 리소스를 생성하고, 동일한 내용으로 PUT을 리소스에 요청을 해도 결과는 같게 된다.

즉, PUT과 POST는 멱등성과 리소스 결정권에 따라 나뉜다고 볼 수 있다. 멱등성을 갖지 않고 리소스를 서버가 결정하면 POST, 멱등성을 가지고 있으며 리소스를 클라이언트가 결정하면 PUT!

## 5. DELETE
원격지 웹 서버에 파일을 삭제하기 위해 사용되며 PUT과는 반대 개념의 메소드이다.

서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다. 클라이언트는 삭제가 수행되는 것을 보장하지 못한다. HTTP 명세에는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문이다.

보통 대부분의 경우 Idempotent하면 safe한데, DELETE는 Idempotent하지만 리소스를 변경하므로 safe하지 않다.

## 6. PATCH
PUT과 비슷하게, 리소스 수정 시 사용된다. 반면 리소스를 부분 수정시 사용된다는 것이 개념적인 차이점이다.

PUT은 문서 자체의 교체만을 허용하며, 만약 전체가 아닌, 일부만 전달할 경우, 전달한 필드외 모드 null이나 초기값으로 처리된다.

반면, PATCH는 자원의 부분 교체가 가능하며, 수정할 JSON일부를 보낸다고 할 때, 해당 필드만 수정된다.

PUT과 마찬가지로 리소스의 위치를 클라이언트가 알고 있을 때 사용한다.

## 7. TRACE
자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.

클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프록시, 게이트웨이 등의 어플리케이션을 통과할 수 있다.

이들에게는 원래의 HTTP 요청을 수정할 수 있는 기회가 있다.

TRACE는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.

TRACE는 주로 디버깅용으로 사용된다.

## 8. OPTIONS
OPTIONS 메소드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다.

서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.

응답메시지 헤더에 Allow 필드를 포함해서 돌려준다.

## 9. CONNECT
요청된 리소스와 양방향 통신을 시작한다.

터널을 여는 데 사용할 수 있다.

## 출처
[MDN web docs](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods)

[Minsub's Blog](https://gyrfalcon.tistory.com/entry/HTTP-%EC%9D%91%EB%8B%B5-%EC%BD%94%EB%93%9C-%EC%A2%85%EB%A5%98-HTTP-%EB%A9%94%EC%86%8C%EB%93%9C-%EC%A2%85%EB%A5%98)

[필오의 개발 docs](https://feel5ny.github.io/2019/08/16/HTTP_003_02/)

[goodGid's Dev Blog](https://goodgid.github.io/HTTP-Method-Post-vs-Put-vs-Patch/)